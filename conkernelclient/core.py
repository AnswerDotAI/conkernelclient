"""Concurrent-safe Jupyter KernelClient"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto #0
__all__ = ['ConKernelClient', 'ConKernelManager']

# %% ../nbs/00_core.ipynb #d3b521c0
from queue import Empty
from asyncio import create_task
from jupyter_client import KernelClient, AsyncKernelClient
from jupyter_client.session import Session
from jupyter_client.channels import AsyncZMQSocketChannel
from zmq.error import ZMQError
from jupyter_client.kernelspec import KernelSpec
from jupyter_client import AsyncKernelManager
from traitlets import Type
import asyncio, zmq.asyncio, time

# %% ../nbs/00_core.ipynb #374b75d0
if not hasattr(Session, '_orig_send'): Session._orig_send = Session.send

def _send(self, stream, msg_or_type, content=None, parent=None, ident=None,
        buffers=None, track=False, header=None, metadata=None):
    msg = self._orig_send(stream, msg_or_type, content=content, parent=parent,
                         ident=ident, buffers=buffers, track=track, header=header, metadata=metadata)
    # Force a sync, ensuring the send is fully registered internally
    # Avoids a race where the lock releases, another thread immediately calls send(),
    # and now 2 threads are interacting with the internal state before I/O thread has caught up
    if stream:
        if hasattr(stream, 'io_thread'): stream.io_thread.socket.get(zmq.EVENTS)
        elif hasattr(stream, 'getsockopt'): stream.getsockopt(zmq.EVENTS)
    return msg

Session.send = _send

# %% ../nbs/00_core.ipynb #d6a5fa6a
class ConKernelClient(AsyncKernelClient):
    async def start_channels(self, shell:bool=True, iopub:bool=True, stdin:bool=True, hb:bool=True, control:bool=True):
        "Start channels, wait for ready, and launch background shell-reply reader"
        super().start_channels(shell=shell, iopub=iopub, stdin=stdin, hb=hb, control=control)
        await self.wait_for_ready()
        self._pending = {}
        _ready = asyncio.Event()
        async def _reader():
            _ready.set()
            while True:
                try: reply = await self.get_shell_msg(timeout=None)
                except Exception as e:
                    for q in self._pending.values(): await q.put(e)
                    if self._pending: logging.warning(f"_reader died with pending - {self._pending}: {e}")
                    else: logging.warning(f"_reader died with no pending: {e}")
                    break
                q = self._pending.get(reply["parent_header"].get("msg_id"))
                if q: await q.put(reply)
        self._shell_reader_task = asyncio.create_task(_reader())
        await _ready.wait()
        await asyncio.sleep(0.2)
        return self

    def stop_channels(self):
        "Stop channels and cancel the background shell-reply reader task"
        super().stop_channels()
        if (tk := getattr(self, '_shell_reader_task', None)):
            tk.cancel()
            self._shell_reader_task = None
        time.sleep(0.2)

    async def _async_recv_reply(self, msg_id, timeout=None, channel="shell"):
        if channel == "control": return await self._async_get_control_msg(timeout=timeout)
        q = self._pending[msg_id]
        try:
            res = await asyncio.wait_for(q.get(), timeout)
            if isinstance(res, Exception): raise res
            return res
        except asyncio.TimeoutError as e: raise TimeoutError("Timeout waiting for reply") from e
        finally: self._pending.pop(msg_id, None)

    def execute(self, code, user_expressions=None, allow_stdin=None, reply=False, subsh_id=None,
                cts_typ='code', timeout=60, msg_id=None, **kw):
        "Send an execute request, returning a coroutine for the reply if `reply`, else the msg_id"
        if user_expressions is None: user_expressions = {}
        if allow_stdin is None: allow_stdin = self.allow_stdin
        content = dict(user_expressions=user_expressions, allow_stdin=allow_stdin, subsh_id=subsh_id, **kw)
        content[cts_typ] = code
        msg = self.session.msg("execute_request", content)
        if msg_id is not None: msg["header"]["msg_id"] = msg_id
        if subsh_id is not None: msg["header"]["subshell_id"] = subsh_id
        msg_id = msg["header"]["msg_id"]
        if reply: self._pending[msg_id] = asyncio.Queue(maxsize=1)
        self.shell_channel.send(msg)
        if not reply: return msg_id
        return self._async_recv_reply(msg_id, timeout=timeout)

    async def stdin_send(self, msg:dict):
        "Send on `stdin_channel` then ping event loop"
        self.stdin_channel.send(msg)
        await asyncio.sleep(0)

# %% ../nbs/00_core.ipynb #b828c222
class ConKernelManager(AsyncKernelManager): client_class,client_factory = ConKernelClient,Type(ConKernelClient)
